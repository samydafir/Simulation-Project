\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage{inputenc}

\title{Farbdrucker Scheduling}
\author{Dominik Baumgartner, Thomas Samy Dafir, Laurentiu Vlad}
\date{}

\begin{document}
	\maketitle
	
	\section{Aufgabenstellung}
	Es soll ein Szenario simuliert werden, bei dem 2 Farbdrucker mehreren Usern zur Verfügung stehen und in gewissen Zeitabständen Print-Jobs mit
	verschiedenen Prioritäten und Abarbeitungszeiten erstellt werden. Insgesamt gibt es 3 Prioritätslevels: Student (niedrig), Professor (mittel), System (hoch). Jobs
	werden in Queues gesammelt und von beiden Druckern abgearbeitet. Dabei ist es immer möglich, dass jobs mit niedrigerer Priorität während ihrer Bearbeitung in 
	einem Drucker von Jobs höherer Priuorität unterbrochen werden können, sprich Professoren-Jobs unterbrechen Studenten-Jobs, System-jobs unterbrechen alle 
	anderen. Unterbrochene Jobs werden so bald als möglich wieder fortgesetzt.
	
	\section{Modell}
	Um den Sachverhalt aus der Aufgabenstellung simulieren zu können wurde ein Modell bestehend aus 4 Prozessen und einer Model-Klasse erstellt (+ 1 weiterer Prozess für die Erweiterung).
	Im folgenden wird kurz auf die Aufgabe eines jeden Prozesses eingegangen und am Schluss das Zusammenspiel der einzelnen Prozesse erklärt. Außerden gehen wir noch kurz auf die Veränderungen
	ein, die nötig waren, um unsere Erweiterung zu realisieren.
	
	\subsection{Allgemein}
	Das Modell wurde so definiert, dass 2 Drucker existieren, von denen jeder seine eigene Drucker-Queue verwaltet. Jeder Neue Druckauftrag wird also bei der Erstellung einem Drucker zugeordnet
	und dann von diesem abgearbeitet. Weiters verwaltet auch jeder Drucker seine eigene Interrupted-Queue für unterbrochene Aufträge.
	
	\subsection{NewJobProcess}
	Wie in der Aufgabenstellung beschrieben, erhalten unsere beiden Drucker in gewissen Zeitabständen Druckaufträge unterschiedlicher Priorität. Diese werden vermutlich von Usern oder den System
	in auftrag gegeben. Um dies zu simulieren brauchen wir natürlich eine Art ``Job-Generator''. Diese Aufgabe wird vom $NewJobProcess$ übernommen. NewJobProcess läuft während der gesamten 
	Simulationsdauer und erstellt in gewissen Zeitabständen neue Jobs mit einer bestimmten Ausführungsdauer. Danach wird für eine gewisse Zeit gewartet und danach wieder ein Job erstellt. Die Warte-
	und Ausführungszeiten werden von einem $ContDistUniform$-Objekt im Modell bezogen. Ein erstellter Prozess wird sofort aktiviert. Da wir 3 verschiene Arten von Jobs simulieren, benötigen wir auch
	3 Instanzen dieser Klasse.
	
	\subsection{JobProcess}
	Der $JobProcess$ wird wie bereits beschrieben von $NewJobProcess$ erstellt und sofort aktiviert. Dieser Prozess repräsentiert einen Druckauftrag. Das Verhalten wurde so definiert, dass jedes
	$JobProcess$-Objekt selbst entscheidet, in welche Queue er sich einordnet. Jeder Job analysiert nachdem er aktiviert wurde beide Drucker-Queues und ordnet sich in jene mit der geringsten
	Gesamtbearbeitungszeit ein. Hier werden 2 Situationen unterschieden. Ist ein Drucker nicht beschäftigt, reiht sich der Job sofort in dessen Queue ein, setzt diesen auf $besetzt$ und aktiviert ihn, sind 
	jedoch beide Drucker besetzt, berechnet der Job beide Gesamtbearbeitungszeiten und reiht sich beim Drucker mit dem kleineren Wert ein. In der Erweiterung wird zusätzlich noch überprüft, ob sich ein Drucker im			Wartungsmodus befindet. Ist dies der Fall, reiht sich der Job beim anderen Drucker ein.
	
	\subsection{PrinterProcess}
	Der $PrinterProcess$ repräsentiert einen Drucker. Wir benötigen also 2 Instanzen dieser Klasse, um das Modell zu realisieren. Ein PrinterProcess läuft ebenfalls während der gesamten Simulationsdauer, wird
	jedoch zwischendurch immer wieder auf hold gesetzt, was der Abarbeitung eines Jobs entspricht. Der Drucker holt sich immer den Job mit der höchsten Priorität aus der Queue mit der höchsten Priorität (die 			Interrupted Queue, falls diese nicht leer ist).
	
	
	
	\subsection{Supervisor}
	Der Supervisor steuert die Unterbrechung von Prozessen, die gerade bearbeitet werden. Eine Instanz dieser Klasse überwacht jeweils einen Drucker und wird immer dann aktiviert, wenn sich ein 
	neuer $JobProcess$ in eine Queue einordnet. Der Supervisor vergleicht immer die Priorität des aktuellen Jobs im Drucker mit der des neu eingefügten Job. Ist die Priorität des neuen Job höher, aktiviert
	der $Supervisor$ den jeweiligen Drucker (der während der Abarbeitung eines Auftrags auf hold gesetzt ist). Der restliche Unterbrechungsvorgang mitsamt der Verschiebung des aktuellen Jobs in die
	Interrupted-Queue wird vom (dann wieder aktiven) Drucker übernommen. Der $Supervisor$-Prozess wird dann wieder auf passivate gesetzt und wartet darauf, von einem neuen Job wieder aktiviert zu 
	werden.
	
	
	\section{Ergebnisse}
	
	








\end{document}