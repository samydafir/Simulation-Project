\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage{inputenc}

\title{Farbdrucker Scheduling}
\author{Dominik Baumgartner, Thomas Samy Dafir, Laurentiu Vlad}
\date{}

\begin{document}
	\maketitle
	
	\section{Aufgabenstellung}
	Es soll ein Szenario simuliert werden, bei dem 2 Farbdrucker mehreren Benutzern zur Verfügung stehen und in gewissen Zeitabständen Print-Jobs mit
	verschiedenen Prioritäten und Abarbeitungszeiten erstellt werden. Insgesamt gibt es 3 Prioritäten: Student (niedrig), Professor (mittel), System (hoch). Jobs
	werden in Queues gesammelt und von beiden Druckern abgearbeitet. Dabei ist es immer möglich, dass Jobs mit niedrigerer Priorität während ihrer Bearbeitung in 
	einem Drucker von Jobs höherer Priorität unterbrochen werden können, sprich Professoren-Jobs unterbrechen Studenten-Jobs, System-Jobs unterbrechen alle 
	anderen. Unterbrochene Jobs werden so bald als möglich wieder fortgesetzt.
	
	\section{Modell}
	Um den Sachverhalt aus der Aufgabenstellung simulieren zu können wurde ein Modell bestehend aus 4 Prozessen und einer Model-Klasse erstellt (+ 1 weiterer Prozess für die Erweiterung).
	Im Folgenden wird kurz auf die Aufgabe eines jeden Prozesses und seinen Beitrag zum Gesamtmodell eingegangen. Hierbei wird auch direkt auf die Erweiterung (Wartung) eingegangen. \\
	Als Simulationsdauer wurden 10 Stunden gewählt. Dies soll einen normalen Büro-/Uni- Arbeitstag repräsentieren.
	
	\subsection{Allgemein}
	Das Modell wurde so definiert, dass 2 Drucker existieren, von denen jeder seine eigene Drucker-Queue verwaltet. Jeder neue Druckauftrag wird also bei der Erstellung einem Drucker zugeordnet
	und dann von diesem abgearbeitet. Weiters verwaltet auch jeder Drucker seine eigene $InterruptedQueue$ für unterbrochene Aufträge.
	
	\subsection{NewJobProcess}
	Wie in der Aufgabenstellung beschrieben, erhalten unsere beiden Drucker in gewissen Zeitabständen Druckaufträge unterschiedlicher Priorität. Diese werden vermutlich von Usern oder dem System
	in Auftrag gegeben. Um dies zu simulieren brauchen wir natürlich eine Art ``Job-Generator''. Diese Aufgabe wird vom $NewJobProcess$ übernommen. $NewJobProcess$ läuft während der gesamten 
	Simulationsdauer und erstellt in gewissen Zeitabständen neue Jobs mit einer bestimmten Ausführungsdauer. Danach wird für eine gewisse Zeit gewartet bevor wieder ein Job erstellt wird. Die Warte-
	und Ausführungszeiten werden von einem $ContDistUniform$-Objekt in der Modell Klasse bezogen. Ein erstellter Prozess wird sofort aktiviert. Da wir 3 verschiedene Arten von Jobs simulieren, benötigen 
	wir auch 3 Instanzen dieser Klasse.
	
	\subsection{JobProcess}
	Der $JobProcess$ wird, wie bereits beschrieben, vom $NewJobProcess$ erstellt und sofort aktiviert. Dieser Prozess repräsentiert einen Druckauftrag. Das Verhalten wurde so definiert, dass jedes
	$JobProcess$-Objekt selbst entscheidet, in welche Queue es sich einordnet. Jeder Job analysiert nachdem er aktiviert wurde beide Drucker-Queues und ordnet sich in jene mit der geringsten
	Gesamtbearbeitungszeit ein. Hier werden 2 Situationen unterschieden. Ist ein Drucker nicht beschäftigt, reiht sich der Job sofort in dessen Queue ein, setzt diesen auf $besetzt$ und aktiviert ihn, sind 
	jedoch beide Drucker besetzt, berechnet der Job beide Gesamtbearbeitungszeiten und reiht sich beim Drucker mit dem kleineren Wert ein. In der Erweiterung wird zusätzlich noch überprüft, ob sich ein 
	Drucker im	Wartungsmodus befindet. Ist dies der Fall, reiht sich der Job beim anderen Drucker ein.
	
	\subsection{PrinterProcess}
	Der $PrinterProcess$ repräsentiert einen Drucker. Wir benötigen also 2 Instanzen dieser Klasse, um das Modell zu realisieren. Ein $PrinterProcess$ läuft während der gesamten Simulationsdauer, wird
	jedoch zwischendurch immer wieder auf hold gesetzt, was der Abarbeitung eines Jobs entspricht. Der Drucker holt sich immer den Job mit der höchsten Priorität aus der Queue mit der höchsten Priorität (die 
	$InterruptedQueue$, falls diese nicht leer ist). Der Drucker wird dann auf hold gesetzt (bearbeitet den Job). Jetzt können 2 Situationen eintreten. Im regulären Fall bearbeitet der Drucker den Job komplett,
	beendet ihn und holt sich den nächsten Job aus der Queue mit der höchsten Priorität. Im zweiten Fall bearbeitet der Drucker den Job nur teilweise und wird dann unterbrochen, da sich ein Job mit
	höherer Priorität in der $JobQueue$ befindet ($Supervisor$ vergleicht Jobs und aktiviert den Drucker). Er berechnet dann die Restzeit des aktuellen Jobs, weist sie diesem zu und verschiebt ihn in die
	$InterruptedQueue$. Außerdem wird im Job eine $interruptable$-Flag auf $false$ gesetzt. Dies wurde von uns so definiert, um zu verhindern, dass der gleiche Job immer wieder unterbrochen wird. Weiters
	 wird der Drucker auf $interrupted$ gesetzt, was bewirkt, dass er jetzt nicht den Job aus der Queue mit der höchsten Priorität wählt (das wäre ja die $InterruptedQueue$ mit dem soeben unterbrochenen Job),
	 sondern den neuen Job aus der $JobQueue$ (der der den aktuellen Job unterbrochen hat). Hier können natürlich während der Abarbeitung wieder die gleichen 2 soeben beschriebenen Situationen eintreten.
	
	\subsection{Supervisor}
	Der $Supervisor$ steuert die Unterbrechung von Prozessen, die gerade bearbeitet werden. Eine Instanz dieser Klasse überwacht jeweils einen Drucker und wird immer dann aktiviert, wenn sich ein 
	neuer $JobProcess$ in eine $JobQueue$ einordnet. Der Supervisor vergleicht immer die Priorität des aktuellen Jobs im Drucker mit der des neu eingefügten Jobs. Ist die Priorität des neuen Job höher, aktiviert
	der $Supervisor$ den jeweiligen Drucker (der während der Abarbeitung eines Auftrags auf hold gesetzt ist). Der restliche Unterbrechungsvorgang mitsamt der Verschiebung des aktuellen Jobs in die
	$InterruptedQueue$ wird vom (dann wieder aktiven) Drucker übernommen. Der $Supervisor$-Prozess wird dann wieder auf passivate gesetzt und wartet darauf, von einem neuen Job wieder aktiviert zu 
	werden.
	
	\subsection{PrinterInkEmptyProcess (Erweiterung)}
	Dieser Prozess ist Teil unserer Erweiterung. Er wird in unserem Fall 2 mal aktiviert und versetzt dabei einen zufällig gewählten Drucker in den Wartungsmodus, indem er im $PrinterProcess$ ein Flag setzt. 
	Der Drucker reagiert darauf, indem er alle Aufträge aus seinen Queues in die des anderen Drucker verschiebt. Auch der aktuelle Job wird dem anderen Drucker zugewiesen und neu abgearbeitet. Dies wurde 
	so gewählt, um sicherzustellen, dass Dokumente an einem einzigen Ort komplett ausgedruckt werden. sämtliche neu ankommenden Jobs reihen sich nun auch direkt in die Queue des anderen Druckers
	ein. Ist die Wartung beendet, werden die Aufträge des nicht-gewarteten Druckers nicht wieder aufgeteilt. Die Längen der $JobQueues$ beider Drucker gleichen sich sowieso wieder aus, da sich neue Jobs
	immer in die kürzere einreihen (bis zum Längenausgleich ist dies die des gewarteten Druckers).
	
	\newpage
	\section{Ergebnisse}
	
	








\end{document}